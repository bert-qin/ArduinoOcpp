{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>MicroOCPP is an OCPP client which runs on microcontrollers and enables EVSEs to participate in OCPP charging networks. As a software library, it can be added to the firmware of the EVSE and will become a new part of it. If the EVSE has already an internet controller, then most likely, no extra hardware is required.</p> <p>Technical introduction</p> <p>Migrating to v1.0</p> <p>Modules</p> <p>Development tools and basic prerequisites</p> <p>Security whitepaper</p> <p>Documentation WIP. See the GitHub Readme or the API description as reference.</p>"},{"location":"intro-tech/","title":"Technical introduction","text":"<p>This chapter covers the technical concepts of MicroOCPP.</p>"},{"location":"intro-tech/#scope-of-microocpp","title":"Scope of MicroOCPP","text":"<p>The OCPP specification defines a charger data model, operations on the data model and the resulting physical behavior on the charger side. MicroOCPP implements the full scope of OCPP, i.e. a minimalistic data store for the data model, the OCPP operations and an interface to the surrounding firmware.</p> <p>Another part of OCPP is its messaging mechanism, the so-called Remote Procedure Calls (RPC) framework. MicroOCPP also implements the specified RPC framework with the required guarantees of message delivery or the corresponding error handling.</p> <p>At the lowest layer, OCPP relies on standard WebSockets. MicroOCPP works with any WebSocket library and has a lean interface to integrate them.</p> <p>The high-level API in <code>MicroOcpp.h</code> bundles all touch points of the EVSE firmware with the OCPP library.</p> <p> Overview of the architecture </p>"},{"location":"intro-tech/#high-level-ocpp-support","title":"High-level OCPP support","text":"<p>Being a full implementation of OCPP, MicroOCPP handles the OCPP communication, i.e. it sends OCPP requests and processes incoming OCPP requests autonomously. The messages are triggered by the internal data model and by input from the high-level API. Incoming OCPP requests are used to update the internal data model and if an action on the charger is required, the library signals that to the main firmware through the high-level API.</p> <p>In consequence, the high-level API decouples the main firmware from the OCPP communication and hides the operations. This has the following good reasons:</p> <ul> <li>The high-level API guarantees correctnes of the OCPP integration. As soon as the charger adopts it properly, it is fully OCPP-compliant</li> <li>The hardware-near design decreases the integration effort into the firmware hugely</li> <li>The API won't change substantially for the OCPP 2.0.1 upgrade. The EVSE will get OCPP 2.0.1 support on the fly by a later firmware update</li> </ul>"},{"location":"intro-tech/#customizability","title":"Customizability","text":"<p>One core principle of the architecture of MicroOCPP is the customizability and the selective usage of its components.</p> <p>Selective usage of components means that the EVSE firmware can use parts of MicroOCPP and work with its own implementation for the rest. In that case only the selected parts of MicroOCPP will be compiled into the firmware. For example, the main firmware can use the RPC framework and build a custom implementation of the OCPP logic on top of it. This could be necessary if the OCPP behavior should be tightly coupled to other modules of the firmware. In a different scenario, the EVSE firmware could already contain an extensive RPC framework and the OCPP client should reuse it. Then, only the business logic and high-level API are of interest.</p> <p> Selective usage of MicroOCPP </p> <p>Customizations of the library allow to integrate use cases for which the high-level API is too restrictive. The high-level API is designed to provide a facade for the expected usage of the library, but since the charging sector is driven by innovation, new use cases for OCPP emerge every day. If a custom use case cannot be integrated on the API level, the main firmware can access the internal data structures of MicroOCPP and complement the required functionality or replace parts of the internal behavior with custom implementations which fits the concrete scenarios better.</p>"},{"location":"intro-tech/#main-loop-paradigm","title":"Main-loop paradigm","text":"<p>MicroOCPP works with the common main-loop execution model of microcontrollers. After initialization, the EVSE firmware most likely enters a main-loop and repeats it infinitely. To run MicroOCPP, a call to its loop function must be placed into the main loop of the firmware. Then at each main-loop iteration, MicroOCPP executes its internal routines, i.e. it processes input data, updates its data model, executes operations and creates new output data. The MicroOCPP loop function does not block the main loop but executes immediately. This library does not contain any delay functions. Some activities of the library spread over many loop iterations like the start of a charging session which needs to await the approval of an NFC card and a hardware diagnosis of the high power electronics for example. All activities in MicroOCPP support the distribution over many loop calls, leading to a pseudo-parallel execution behavior.</p> <p>No separate RTOS task is needed and MicroOCPP does not have an internal mechanism for multi-task synchronization. However, it is of course possible to create a dedicated OCPP task, as long as extra care is taken of the synchronization.</p>"},{"location":"intro-tech/#how-the-api-works","title":"How the API works","text":"<p>The high-level API consists of four parts:</p> <ul> <li>Library lifecycle: The library has initialize functions with a few initialization options. Dynamic system components like the WebSocket adapter need to be set at initialization time. The deinitialize function reverts the library into an unitialized state. That's useful for memory inspection tools like valgrind or to disable the OCPP communication. The loop function also counts as part of the lifecycle management.</li> <li>Sensor Inputs: EVSEs are mechanical systems with a variety of sensor information. OCPP is used to send parts of the sensor readings to the server. The other part of the sensor data flows into the local charger model of MicroOCPP where it is further processed. To update MicroOCPP with the input data from the sensors, the firmware needs to bind the sensors to the library. An Input-binding, or in short Input, is a function which transfers the current sensor value to MicroOCPP. Inputs are callback functions which read a specific sensor value and pass the value in the return statement. The firmware defines those callback functions for each sensor and adds them to MicroOCPP during initialization. After initialization, MicroOCPP uses the callbacks and executes them to fetch the most recent sensor values.  This concept is reused for the data Outputs of the library to the firmware, where the callback applies output data from MicroOCPP to the firmware.</li> <li>Transaction management: OCPP considers EVSEs as vending machines. To enable payment processing and the billing of the EVSE usage, all charging activity is assigned to transactions. A big portion of OCPP is about transactions, their prerequisites, runtime and their termination scenarios. The MicroOCPP API breaks transactions down into an initiation and termination function and gives a transparent view on the current process status, authorization result and offline behavior strategy. For non-commercial setups, the transaction mechanism is the same but has only informational purposes.</li> <li>Device management: MicroOCPP implements the OCPP side of the device management operations. For the actual execution, the firmware needs to provide the charger-side implementations of the operations to MicroOCPP by passing handler functions to the API. For example, the OCPP server can restart the charger. Upon receipt of the request, MicroOCPP terminates the transactions and eventually triggers the system restart using the handler function which the firmware has provided through the high-level API.</li> </ul>"},{"location":"intro-tech/#transaction-safety","title":"Transaction safety","text":"<p>Software in EVSEs needs to withstand hazardous operating conditions. EVSEs are located on the street or in garages where the WiFi or LTE signal strength is often weak, leading to long offline periods or where random power cuts can occur. In addition to that, the lack of process virtualization on microcontrollers means that a malfunction in one part of the firmware leads to the crash of all other parts.</p> <p>The transaction process of MicroOCPP is robust against random failures or resets. A minimal transaction log on the flash storage ensures that each operation on a transaction is fully executed. It will always result in a consistent state between the EVSE and the OCPP server, even over resets of the microcontroller. The RPC queue facilitates this by tracking the delivery status of relevant messages. If the microcontroller is reset while the delivery status of a message is unknown, MicroOCPP takes up the message delivery again at the next start up and completes it.</p> <p>A requirement for the transaction safety feature is the availability of a journaling file system. Examples include LittleFS, SPIFFS and the POSIX file API, but some microcontroller platforms don't support this natively, so an extension would be required.</p>"},{"location":"intro-tech/#unit-testing","title":"Unit testing","text":"<p>MicroOCPP includes a number of unit tests based on the Catch2 framework. A GitHub Action runs the unit tests against each new commit in the MicroOCPP repository, which ensures that new features don't break old code.</p> <p>The scope of the unit tests is to to ensure a correct implementation of OCPP and to validate the high-level API against its definition. For that, it is not necessary to establish an actual test connection to an OCPP server. In fact, real-world communication would disturb the tests and make them undeterministic. That's why the test suite is fully based on an integrated, tiny OCPP test server which the OCPP client reaches over a loopback connection. The test suite does not access the WebSocket library. When making the unit tests of the main firmware, it is not necessary to check the full OCPP communication, but only to validate correct usage of the high-level API. An example of how the library can be initialized with a loopback connection can be found in its test suite.</p>"},{"location":"intro-tech/#microcontroller-optimization","title":"Microcontroller optimization","text":"<p>As a library for microcontrollers, the design of MicroOCPP considers the strict memory limits and complies with the best practices of embedded software development. Also, a few measures were taken to optimize the memory usage which include the spare inclusion of external libraries, an optimization of the internal data structures and the exclusion of C++ run-time type information (RTTI) and exceptions. Features of C++ which may have a larger footprint are carefully used such as the standard template library (STL) and lambda functions. The STL increases the robustness of the code and lambdas prove to be a powerful tool to deal with the complexity of asynchronous data processing in embedded systems. That's also why the high-level API has many functional parameters.</p> <p>Because of the high importance of C in the embedded world, MicroOCPP provides its high-level API in C too. It is typically simple to instruct the compiler to compile and link the C++-based library in a C-based firmware development. In case that the firmware requires custom features which are not part of the C-API, then the firmware can implement it in a new C++ source file, export the new functions to the C namespace and use it normally in the main source.</p> <p>While memory constraints are of concern, the execution time generally is not. OCPP is rather uncomplex on the algorithmic side for clients, since there is no need for elaborate planning algorithms or complex data transformations.</p> <p>Low resource requirements also allow new usage areas on top of EV charging. For example, MicroOCPP has been ported to ordinary IoT equipment such as Wi-Fi sockets to integrate further electric devices into OCPP networks.</p> <p>Although MicroOCPP is optimized for the usage on microcontrollers, it is also suitable for embedded Linux systems. With more memory available, the upper limits of the internal data structures can be increased, leading to a more versatile support of charging use cases. Also, the separation of the charger firmware into multiple processes can lead to more robustness. MicroOCPP can be extended by an inter-process communication (IPC) interface to run in a separate process.</p>"},{"location":"migration/","title":"Migrating to v1.1","text":"<p>As a new minor version, all features should work the same as in v1.0 and existing integrations are mostly backwards compatible. However, some fixes / cleanup steps in MicroOCPP require syntactic changes or special consideration when upgrading from v1.0 to v1.1. The known pitfalls are as follows:</p> <ul> <li>The default branch has been renamed from <code>master</code> into <code>main</code></li> <li>Need to include extra headers: the transitive includes have been cleaned a bit. Probably it's necessary to add more includes next to <code>#include &lt;MicroOcpp.h&gt;</code>. E.g.<code>#include &lt;MicroOcpp/Model/Diagnostics/DiagnosticsService.h&gt;</code><code>#include &lt;MicroOcpp/Model/FirmwareManagement/FirmwareService.h&gt;</code></li> <li><code>ocppPermitsCharge()</code> does not consider failures reported by the charger anymore. Before v1.1 it was possible to report failures to MicroOCPP using ErrorCodeInputs and then to rely on <code>ocppPermitsCharge()</code> becoming false when a failure occurs. For backwards compatibility, complement any occurence to <code>ocppPermitsCharge() &amp;&amp; !isFaulted()</code></li> <li><code>setEnergyMeterInput</code> changed the expected return type of the callback function from <code>float</code> to <code>int</code> (see #301)</li> <li>The return type of the UnlockConnector handler also changed from <code>PollResult&lt;bool&gt;</code> to enum <code>UnlockConnectorResult</code> (see #271)</li> </ul> <p>If upgrading MicroOcppMongoose at the same time, then the following changes are very important to consider:</p> <ul> <li>Certificates are no longer copied into heap memory, but the MO-Mongoose class takes the passed certificate pointer as a zero-copy parameter. The string behind the passed pointer must outlive the MO-Mongoose class (see #10)</li> <li>WebSocket authorization keys are no longer stored as c-strings, but as <code>unsigned char</code> buffers. For backwards compatibility, a null-byte is still appended and the buffer can be accessed as c-string, but this should be tested in existing deployments. Furtermore, MicroOCPP only accepts hex-encoded keys coming via ChangeConfiguration which is mandated by the standard. This also may break existing deployments (see #4).</li> </ul> <p>If accessing the MicroOCPP modules directly (i.e. not over <code>MicroOcpp.h</code> or <code>MicroOcpp_c.h</code>) then there are likely some more modifications to be done. See the history of pull requests where each change to the code is documented. However, if the existing integration compiles under the new MO version, then there shouldn't be too many unexpected incompatibilities.</p>"},{"location":"migration/#migrating-to-v10","title":"Migrating to v1.0","text":"<p>The API has been continously improved to best suit the common use cases for MicroOCPP. Moreover, the project has been given a new name to prevent confusion with the relation to the Arduino platform and to reflect the project goals properly. With the new project name, the API has been frozen for the v1.0 release.</p>"},{"location":"migration/#adopting-the-new-project-name-in-existing-projects","title":"Adopting the new project name in existing projects","text":"<p>Find and replace the keywords in the following.</p> <p>If using the C-facade (skip if you don't use anything from ArduinoOcpp_c.h):</p> <ul> <li><code>AO_Connection</code> to <code>OCPP_Connection</code></li> <li><code>AO_Transaction</code> to <code>OCPP_Transaction</code></li> <li><code>AO_FilesystemOpt</code> to <code>OCPP_FilesystemOpt</code></li> <li><code>AO_TxNotification</code> to <code>OCPP_TxNotification</code></li> <li><code>ao_set_console_out_c</code> to <code>ocpp_set_console_out_c</code></li> </ul> <p>Change this in any case:</p> <ul> <li><code>ArduinoOcpp</code> to <code>MicroOcpp</code></li> <li><code>\"AO_</code> to <code>\"Cst_</code> (define build flag <code>MO_CONFIG_EXT_PREFIX=\"AO_\"</code> to keep old config keys)</li> <li><code>AO_</code> to <code>MO_</code></li> <li><code>ocpp_</code> to <code>mocpp_</code></li> </ul> <p>Change this if used anywhere:</p> <ul> <li><code>ao_set_console_out</code> to <code>mocpp_set_console_out</code></li> <li><code>ao_tick_ms</code> to <code>mocpp_tick_ms</code></li> </ul> <p>If using the C-facade, change this as the final step:</p> <ul> <li><code>ao_</code> to <code>ocpp_</code></li> </ul>"},{"location":"migration/#further-api-changes-to-consider","title":"Further API changes to consider","text":"<p>In addition to the new project name, the API has also been reworked for more consistency. After renaming the existing project as described above, also take a look at the changelogs (see Section Changed for v1.0.0).</p> <p>If something is missing in this guide, please share the issue here: https://github.com/matth-x/MicroOcpp/issues/176</p>"},{"location":"modules/","title":"Modules","text":"<p>This chapter gives an overview of the class structure of MicroOCPP.</p>"},{"location":"modules/#context","title":"Context","text":"<p>The Context contains all runtime data of MicroOCPP. Every data object which this library creates is stored in the Context instance, except only the Configuration. So it is the basic entry point to the internals of the library. The structure of the context follows the main architecture as described in this introduction and consists of the Request queue and message deserializer for the RPC framework and the Model object for the OCPP model and behavior (see below).</p> <p>When the library is initialized, <code>getOcppContext()</code> returns the current Context object.</p>"},{"location":"modules/#model","title":"Model","text":"<p>The Model represents the OCPP device model and behavior. OCPP defines a rough charger model, i.e. the hardware parts of the charger and their basic functionality in relation to the OCPP operations. Furthermore, OCPP specifies a few only software related features like the reservation of the charger. This charger model is implemented as straightforward C++ data structures and corresponding algorithms.</p> <p>The implementation of the Model is structured into a top-level Model class and the subordinate Service classes. Each Service class represents a functional block of the OCPP specification and implements the corresponding data structures and functionality. The definition of the functional blocks in MicroOCPP is very similar to the feature profiles in OCPP. Only the Core profile is split into multiple functional blocks to keep a smaller module scope.</p> <p>The following list contains the resulting functional blocks:</p> <ul> <li>Authorization: local information of user identifiers and their authorization status</li> <li>Boot: implementation of the preboot behavior, i.e. sending and processing the BootNotification message</li> <li>ChargingSession: management of charging sessions and control of the high power charging hardware</li> <li>Diagnostics: GetDiagnostics upload routine</li> <li>FirmwareManagement: UpdateFirmware download routine</li> <li>Heartbeat: periodic OCPP Heartbeats (not including WebSocket ping-pongs)</li> <li>Metering: periodic MeterValue messages and local caching</li> <li>Reservation: management of Reservation lists and their effect on the authorization routine</li> <li>Reset: execution of OCPP Reset message</li> <li>Transactions: transaction journal behind StartTransaction and StopTransaction messages and Transaction class for extensions of the transaction mechanism</li> </ul>"},{"location":"modules/#requests","title":"Requests","text":"<p>The Request class and all similarly named classes implement the Remote Procdure Call (RPC) framework of OCPP. A request executes an operation on the remote end of an OCPP connection. If a charger sends a request to a server, then the server will update its data base with the payload and vice versa. After receiving a request, each node replies with a confirmation, acknowledging the successful execution of the operation or notifying about an error.</p> <p>When being offline, outgoing requests must be queued before sending which is implemented in RequestQueue. Queueing is especially challenging for longer offline periods when the number of cached messages exceeds the memory limit. To address this, messages are swapped to the flash memory when the queue limit is reached as implemented in the RequestStore and RequestQueueStorageStrategy class. Incoming messages can be processed directly and don't have an extensive queueing mechanism.</p>"},{"location":"modules/#operations","title":"Operations","text":"<p>Every OCPP operation (e.g. Heartbeat, BootNotification) has a dedicated class for creating outgoing messages, interpreting incoming messages, executing the specified OCPP action and handling responses. Operations work on the data structures of the Model layer.</p> <p>To send operations to the OCPP server, they must be wrapped into a Request object. The RPC framework and operations are separated modules. While the RPC framework (including the Request class) deals with the messaging mechanism and transfering data to the other OCPP device, operations define the effect on the OCPP model and data structure and execute the desired action. The operation classes inherit from Operation which is the interface visible to the Request class.</p> <p>Incoming messages are unmarshalled using the OperationRegistry. During the initialization phase of the library, the Model classes register all supported operations with their name and an instantiator. The instantiator, when executed, provides the Request interpreter with an instance of the corresponding Operation subclasses. It is possible to extend MicroOCPP by adding new Operation instantiators to the registry, or to modify the behavior by overriding the default Operation implementations. In addition to that, event handlers can be set which the RPC queue will notify with the payload once operations are sent or received.</p>"},{"location":"modules/#configuration","title":"Configuration","text":"<p>Configurations like the HeartbeatInterval are managed by the Configuration module which consists of</p> <ul> <li>AbstractConfiguration: a single configuration as a key-value pair without value type<ul> <li>Configuration: a concrete configuration with a value type like <code>bool</code> or <code>const char*</code>. Inherits from AbstractConfiguration</li> </ul> </li> <li>ConfigurationContainer: a collection of AbstractConfigurations and an optional storage implementation. Multiple containers can be set for a separation of the configurations and different storage strategies. Each container has a unique file name<ul> <li>ConfigurationContainerVolatile: no persistency and access to the file system</li> <li>ConfigurationContainerFlash: persistency by storing JSON files on the flash</li> </ul> </li> </ul> <p>If another storage implementation is required (e.g. for syncing with an external configuration manager), then it's possible to add a custom ConfigurationContainer.</p> <p>In the initialization phase, MicroOCPP loads the built-in Configurations with hard-coded factory defaults and a default storage structure. To customize the factory defaults or which ConfigurationContainers will be used, the Configuration module must be initialized before loading the library. To do so, call <code>configuration_init(...)</code>. Then the factory defaults can be applied by calling <code>declareConfiguration&lt;T&gt;(...)</code> with the desired default value. To use a custom ConfigurationContainer, call <code>addConfigurationContainer(...)</code> with the custom implementation. When the library is loaded afterwards, it will use the previously provided Configurations / Containers and create only the data structure which hasn't been set already.</p>"},{"location":"prerequisites/","title":"Development tools and basic prerequisites","text":"<p>This page explains how to work with this library using the appropriate development tools. Skip it if your IDE is set up and you already have an OCPP test server.</p>"},{"location":"prerequisites/#development-tools-prerequisites","title":"Development tools prerequisites","text":"<p>Throughout these document pages, it is assumed that you already have set up your development environment and that you are familiar with the corresponding building, flashing and (basic) debugging routines. MicroOCPP runs in many environments (from the Arduino-IDE to proprietary microcontroller IDEs like the Code Composer Studio). If you do not have any preferences yet, it is highly recommended to get started with VSCode + the PlatformIO add-on, since it is the favorite setup of the community and therefore you find the most related information in the Issues pages of the main repository.</p> <p>There are many high-quality tutorials for out there for setting up VSCode + PIO. The following site covers everything you need to know: https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/</p> <p>Once that's done, adding MicroOCPP is no big deal anymore. However, let's discuss another very important tool for your project first.</p>"},{"location":"prerequisites/#ocpp-server-prerequisites","title":"OCPP Server prerequisites","text":"<p>MicroOCPP is just a client, but all the magic of OCPP lives in the communication between a client and a server. Although it is possible to run MicroOCPP without a real server for testing purposes, the best approach for getting started is to get the hands on a real server. So you can always use the client in a practical setup, see immediate results and simplify development a lot.</p> <p>Perhaps you were already given access to an OCPP server for your project. Then you can use that, it should work fine. If you don't have a server already, it is highly recommended to get SteVe (https://github.com/steve-community/steve). It allows to control every detail of the OCPP operations and shows detail-rich information about the results. And again, it is the favorite test server of the community, so you will find the most related information on the Web. For the installation instructions, please refer to the SteVe docs.</p> <p>In case you can't wait to get started, you can make the first connection test with a WebSocket echo server as a fake OCPP service. MicroOCPP supports that: it can send all messages to an echo server which reflects all traffic. MicroOCPP gets back its own messages and replies to itself with mocked responses. Complicated, but it does work and the console will show a valid OCPP communication. An example echo server is given in the following section. For the further development though, you will definitely need a real OCPP server.</p>"},{"location":"prerequisites/#project-structure","title":"Project structure","text":"<p>MicroOCPP is a library, i.e. it is not a full firmware, but just solves one specific task in your project which is the OCPP connectivity. The project structure should reflect this: typically you download MicroOCPP into a libraries or dependencies subfolder, while the main part of the development takes place in a main source folder. All dependencies of MicroOCPP (i.e. ArduinoJson, see the dependencies sections) should be located in the same libraries or dependencies folder.</p> <p>When the include paths are correctly set up, you should be able <code>#include &lt;MicroOcpp.h&gt;</code> at the top of your own source files. This setup keeps the OCPP library source separate from your integration and gives the project a clear structure.</p>"},{"location":"prerequisites/#dependency-managers","title":"Dependency managers","text":"<p>Currently, the PlatformIO dependency manager is supported. In the <code>platformio.ini</code> manifest, you can add <code>matth-x/MicroOcpp</code> to the <code>lib_deps</code> section.</p>"},{"location":"security/","title":"Security","text":"<p>MicroOCPP is designed to be compatible with IoT devices which leads to special considerations regarding cyber security. This section describes the challenges and security concepts of MicroOCPP.</p>"},{"location":"security/#challenges-of-using-microcontrollers-in-safety-critical-environments","title":"Challenges of using microcontrollers in safety-critical environments","text":"<p>The two challenges are as follows:</p> <ol> <li>Lack of process virtualization in RTOS operating systems</li> <li>Less attention for potential vulnerabilities in the used libraries</li> </ol> <p>In a general purpose OS like Linux, the internet communication modules of an application typically run in a different process than the data base or the hardware supervision / control function. In contrast, on a typical RTOS, all modules are compiled into the same binary, sharing the same address space and lifecycle when being executed. This means that once the network stack crashes, all software on the chip is reset and a vulnerability on the network stack could be exploited to read or manipulate the data of the full runtime environment.</p> <p>Challenge 2) is due to the fact that OCPP uses standard web technology (WebSocket over TLS), but microcontrollers are missing out the most widespread networking software like OpenSSL or the networking libraries of Linux. The available networking libraries for microcontrollers are also audited well (e.g. lwIP, mbedTLS), but in general there is more attention on potential vulnerabilites in the Linux world, because a huge share of commercial IT systems is based on Linux.</p> <p>On the upside, an advantage of microcontrollers is their single purpose usage and thus, reduced complexity. Many security breaches are caused by misconfigured and often even superflous software components (e.g. due to overlooked open ports) which are not a regular part of a microcontroller firmware.</p>"},{"location":"security/#security-measures-of-microocpp","title":"Security measures of MicroOCPP","text":"<p>To address the challenges, the following measures were taken:</p> <ul> <li>Input sanitazion: MicroOCPP only accepts the JSON format for all input. It is validated by ArduinoJson. Every JSON value is checked against the expected format and for conformity with the OCPP specification before using it. The JSON object is discarded immediately after interpretation</li> <li>Transaction safety: to address crashes and random reboots of the microcontroller during operation, all activities of the OCPP library are programmed so that they will either be resumed or fully reverted after reboots, preventing inconsistent states. See also Transaction safety</li> <li>Careful choice of the dependencies: the mandatory dependency, ArduinoJson, has a test coverage of nearly 100% and is fuzzed. The same goes for the recommended WebSocket library, Mongoose. Both projects are very relevant in their field with over 6k and 9k stars on GitHub</li> </ul> <p>Two further measures would be beneficial and could be requested via support request:</p> <ul> <li>Precautious memory allocation: migrating memory management to the stack and where possible would simplify code analysis and reduce the potential of vulnerabilities</li> <li>OCPP fuzzer: as a stateful application protocol, there are specific challenges of developing a fuzzer. An open source fuzzing framework for OCPP could reveal vulnerabilities and be of use for other OCPP projects as well. MicroOCPP is a good foundation for trying new fuzzing approaches. The exposure of the main-loop function and the clock allow a fine-grained access to the program flow and facilitating random alterations of the environment conditions. Furthermore, all persistent data is stored in the JSON format and it is possible to develop a grammatic which contains both a device status and incoming OCPP messages. The Configuration interface could be reused for further status variables which don't need to be persistent in practice, but would improve fuzzing performance when being accessible by the fuzzer.</li> <li>Memory pool: object orientation is a very helpful programming paradigm for OCPP. The standard contains a lot of polymorphic entities and optional or variable length data fields. MicroOCPP makes use of the heap and allocates new chunks of memory as the device model is populated with data. On the upside this allows to save a lot of memory during normal operation, but it also entails the risk of memory depletion of the whole controller. A fixed memory pool for OCPP would encapsulate the heap usage to a certain address space and set a hard limit for the memory consumption and avoid polluting the shared heap area by heap fragmentation. To realize the memory pool, it would be necessary to make the allocate and deallocate functions configurable by the client code. Then appropriate (de)allocators can be injected limiting the memory use to a restricted address area. As a consequence, a more thorough allocation error handling in the MicroOCPP code is required and test cases which randomly suppress allocations to test if the library always reverts to a consistent state. A less invasive alternative to memory pools is to inject measured (de)allocators which just prevent the allocation of new memory chunks after a certain threshold has been exceeded. This programming technique would also allow to create much more fine-grained benchmarks of the library.</li> </ul>"},{"location":"security/#measures-to-be-taken-by-the-evse-vendor","title":"Measures to be taken by the EVSE vendor","text":"<p>As a general rule, the communication controller which is exposed to the internet shouldn't be used for safety-critical tasks on the charging hardware. That's because the networking stack is a very complex piece of software which very likely still has open bugs which can crash the controller despite all the effort to improve it. Safety-critical tasks on the charging hardware shouldn't rely on a controller which could crash at any time because of incoming network traffic. To mitigate this, either the OCPP library and internet functionality should be placed onto a separate chip, or the most vital safety functionality should get a dedicated controller.</p> <p>The recommended Mongoose WebSocket adapter for MicroOCPP supports the OCPP Security Profile 2 (TLS with Basic Authentication) and needs to be provided with the necessary TLS certificate.</p> <p>Most IoT-controllers have built-in mechanisms to ensure the authenticity of their firmware. For example, the Espressif32 supports Secure Boot which is a signature verification of the installed firmware before that firmware is executed. Many platforms also have a built-in signature verification for incoming OTA firmware updates. To prove the authenticity of the charger to the OCPP server, it is also important to keep the WebSocket key secret by encrypting the flash memory. These security mechanisms heavily depend on the host controller which runs MicroOCPP. It is the responsibility of the main firmware to make proper use of them.</p>"},{"location":"security/#ocpp-security-whitepaper-and-iso-15118","title":"OCPP Security Whitepaper and ISO 15118","text":"<p>With MicroOCPP, the recommended way of handling certificates on microcontrollers is to compile them into the firmware binary and to rely on the built-in firmware signature checks of the host microcontroller platform. This lean approach results in a smaller attack vector compared to establishing a separate infrastructure for the server- and firmware certificate. It can be assumed that the OTA functionality of the microcontrollers is thoroughly tested and consequently, reaching a comparable level of robustness would require much effort.</p> <p>In case the certificate handling mechanism of the Security Whitepaper is preferred, then the EVSE vendor needs to implement it via a custom extension. Unfortunately, this mechanism hasn't been requested yet and is not natively supported by MicroOCPP yet. The new custom operations can be implemented by extending the class <code>Operation</code>. A handler for incoming messages can be registered via <code>OperationRegistry::registerOperation(...)</code>. To send custom messages to the server, use <code>Context::initiateRequest(...)</code>.</p> <p>A further challenge for microcontrollers is the relatively low processor speed which becomes relevant for a potential ISO 15118 integration. Some incoming message types (<code>AuthorizationReq</code> and <code>MeteringReceiptReq</code>) include a signature which needs to be verified on the communications controller of the EVSE. Moreover, messages in the ISO 15118 V2G protocol have a maximum round trip time (which is 2 seconds for the message types in question) and so the signature verification is time-contrained. These benchmarks for the Espressif32 show that for some signature algorithms, the verification time can get close or exceed the timing requirements of ISO 15118 if done on the processor only. As a consequence, hardware acceleration by the crypto-core is mandatory to ensure a robust communication between the EVSE and EV. Before making a communications controller with ISO 15118 support, the performance of the host controller should be benchmarked and checked against the requirements.</p> <p>Disclaimer: the outlined risks in this section are not a complete list. Also, every system has unique security challenges which require individual attention. In doubt, please consult an IT-security specialist.</p>"}]}